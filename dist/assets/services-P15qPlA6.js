import{c as e}from"./vendor-supabase-DKeZICmP.js";const s={BASE_URL:"/",DEV:!1,MODE:"production",PROD:!0,SSR:!1,VITE_SUPABASE_ANON_KEY:"",VITE_SUPABASE_URL:""},t=(e,t)=>{const r=("undefined"!=typeof window&&window.__ENV__&&"object"==typeof window.__ENV__?window.__ENV__:{})[e];if(null!=r&&""!==r)return r;let i={};try{i=s||{}}catch(o){i={}}const n=i[e];return null!=n&&""!==n?n:t},r=t("VITE_SUPABASE_URL",""),i=t("VITE_SUPABASE_ANON_KEY","");"undefined"!=typeof window&&window.__ENV__;let n=null;try{r&&i&&(n=e(r,i))}catch(h){}const o={SETLIST_DATA:"performanceMode_setlistData",SONGS_DATA:"performanceMode_songsData",SESSION_ID:"performanceMode_sessionId",IS_LEADER:"performanceMode_isLeader",CACHE_TIMESTAMP:"performanceMode_cacheTimestamp",LAST_ACTIVITY:"performanceMode_lastActivity"},a=6e5;const c=new class{constructor(){this.activeSubscriptions=new Map,this.isInPerformanceMode=!1}isActive(){return this.isInPerformanceMode}setActive(e){this.isInPerformanceMode=e,e&&this.updateLastActivity()}updateLastActivity(){try{localStorage.setItem(o.LAST_ACTIVITY,Date.now().toString())}catch(h){}}isCacheValid(e){try{const e=localStorage.getItem(o.CACHE_TIMESTAMP),s=localStorage.getItem(o.SETLIST_DATA);if(!e||!s)return!1;return Date.now()-parseInt(e)<3e5}catch(h){return!1}}async cleanupStaleSessionsForSetlist(e){try{const{data:s,error:t}=await n.from("performance_sessions").select("*, users(id, name)").eq("setlist_id",e).eq("is_active",!0);if(t)return;if(!s||0===s.length)return;for(const e of s){const s=Date.now()-new Date(e.created_at).getTime()>a,{data:t}=await n.from("session_participants").select("user_id").eq("session_id",e.id).eq("is_active",!0),r=t&&t.length>0;!s&&r||(await n.from("performance_sessions").update({is_active:!1}).eq("id",e.id),await n.from("session_participants").update({is_active:!1}).eq("session_id",e.id))}}catch(h){}}async isLeaderActive(e,s){try{const{data:t}=await n.from("session_participants").select("joined_at, is_active").eq("session_id",s).eq("user_id",e).eq("is_active",!0).single();if(t){const e=new Date(t.joined_at).getTime();return Date.now()-e<a}return!0}catch(h){return!0}}async prefetchAndCacheSetlistData(e){try{const{data:t,error:r}=await n.from("setlists").select("\n          *,\n          sets (\n            id,\n            name,\n            set_order,\n            created_at,\n            set_songs (\n              song_order,\n              songs (\n                id,\n                title,\n                original_artist,\n                key_signature,\n                tempo,\n                performance_note,\n                lyrics,\n                created_at\n              )\n            )\n          )\n        ").eq("id",e).order("set_order",{foreignTable:"sets",ascending:!0}).order("song_order",{foreignTable:"sets.set_songs",ascending:!0}).single();if(r)throw r;if(!t.sets||0===t.sets.length)throw new Error("Setlist has no sets");const i={};t.sets.forEach(e=>{e.set_songs?.forEach(e=>{e.songs&&(i[e.songs.id]=e.songs)})});try{localStorage.setItem(o.SETLIST_DATA,JSON.stringify(t)),localStorage.setItem(o.SONGS_DATA,JSON.stringify(i)),localStorage.setItem(o.CACHE_TIMESTAMP,Date.now().toString())}catch(s){}return{setlistData:t,songsData:i}}catch(h){throw h}}getCachedSetlistData(){try{const e=localStorage.getItem(o.SETLIST_DATA),s=localStorage.getItem(o.SONGS_DATA);return{setlistData:e?JSON.parse(e):null,songsData:s?JSON.parse(s):{}}}catch(h){return{setlistData:null,songsData:{}}}}clearCache(){try{Object.values(o).forEach(e=>{localStorage.removeItem(e)})}catch(h){}}async getActiveSession(e){try{const{data:s,error:t}=await n.from("performance_sessions").select("\n          *,\n          setlists (name),\n          users (id, name, email, role),\n          sets (name),\n          songs (title, original_artist)\n        ").eq("setlist_id",e).eq("is_active",!0).maybeSingle();if(t&&"PGRST116"!==t.code)throw new Error(t.message);return s}catch(h){throw h}}async getOrCreateSession(e,s,t,r="follower"){try{await this.cleanupStaleSessionsForSetlist(e);let i=await this.getActiveSession(e);if(i){const e=await this.isLeaderActive(i.leader_id,i.id);if(i.leader_id===s)return await n.from("performance_sessions").update({created_at:new Date}).eq("id",i.id),{session:i,isLeader:!0,needsChoice:!1};if(!e||"leader"===r&&t>=3){const{data:t,error:r}=await n.from("performance_sessions").update({leader_id:s,created_at:new Date}).eq("id",i.id).select("\n              *,\n              setlists (name),\n              users (id, name, email, role),\n              sets (name),\n              songs (title, original_artist)\n            ").single();if(r)throw r;return e&&await n.from("session_participants").upsert({session_id:i.id,user_id:i.leader_id,is_active:!0},{onConflict:"session_id,user_id"}),{session:t,isLeader:!0,needsChoice:!1}}return"leader"===r?{session:i,isLeader:!1,needsChoice:!0}:(await n.from("session_participants").upsert({session_id:i.id,user_id:s,is_active:!0},{onConflict:"session_id,user_id"}),{session:i,isLeader:!1,needsChoice:!1})}if("leader"===r){const{setlistData:t}=await this.prefetchAndCacheSetlistData(e);if(!t.sets||0===t.sets.length)throw new Error("Setlist has no sets");const r=t.sets[0],i=r.set_songs?.[0]?.songs||null,{data:o,error:a}=await n.from("performance_sessions").insert({setlist_id:e,leader_id:s,current_set_id:r.id,current_song_id:i?.id||null,is_active:!0}).select("\n              *,\n              setlists (name),\n              users (id, name, email, role),\n              sets (name),\n              songs (title, original_artist)\n            ").single();if(a)throw new Error(a.message);return{session:o,isLeader:!0,needsChoice:!1}}return{session:null,isLeader:!1,needsChoice:!0}}catch(h){throw h}}async createSession(e,s){try{await this.cleanupStaleSessionsForSetlist(e);const{setlistData:t}=await this.prefetchAndCacheSetlistData(e);if(!t.sets||0===t.sets.length)throw new Error("Setlist has no sets");const r=t.sets[0],i=r.set_songs?.[0]?.songs||null,{data:o,error:a}=await n.from("performance_sessions").insert({setlist_id:e,leader_id:s,current_set_id:r.id,current_song_id:i?.id||null,is_active:!0}).select("\n          *,\n          setlists (name),\n          users (id, name, email, role),\n          sets (name),\n          songs (title, original_artist)\n        ").single();if(a)throw new Error(a.message);return o}catch(h){throw h}}async takeOverLeadership(e,s){try{const{data:t,error:r}=await n.from("performance_sessions").select("leader_id").eq("id",e).single();if(r)throw r;const{data:i,error:o}=await n.from("performance_sessions").update({leader_id:s,created_at:new Date}).eq("id",e).select("\n          *,\n          setlists (name),\n          users (id, name, email, role),\n          sets (name),\n          songs (title, original_artist)\n        ").single();if(o)throw o;return t.leader_id!==s&&await n.from("session_participants").upsert({session_id:e,user_id:t.leader_id,is_active:!0},{onConflict:"session_id,user_id"}),i}catch(h){throw h}}async joinAsFollower(e,s){try{return await n.from("session_participants").upsert({session_id:e,user_id:s,is_active:!0},{onConflict:"session_id,user_id"}),this.updateLastActivity(),!0}catch(h){throw h}}async requestLeadership(e,s,t){try{const{data:r}=await n.from("leadership_requests").select("id").eq("session_id",e).eq("requesting_user_id",s).eq("status","pending").single();if(r)throw new Error("You already have a pending leadership request");const{data:i,error:o}=await n.from("leadership_requests").insert({session_id:e,requesting_user_id:s,requesting_user_name:t,status:"pending",expires_at:new Date(Date.now()+3e4)}).select().single();if(o)throw o;return i}catch(h){throw h}}async approveLeadershipRequest(e,s){try{const{data:t,error:r}=await n.from("leadership_requests").select("session_id, requesting_user_id").eq("id",e).single();if(r)throw r;await n.from("leadership_requests").update({status:"approved",responded_at:new Date}).eq("id",e);const{data:i,error:o}=await n.from("performance_sessions").update({leader_id:s}).eq("id",t.session_id).select("\n          *,\n          setlists (name),\n          users (id, name, email, role),\n          sets (name),\n          songs (title, original_artist)\n        ").single();if(o)throw o;return i}catch(h){throw h}}async rejectLeadershipRequest(e){try{const{error:s}=await n.from("leadership_requests").update({status:"rejected",responded_at:new Date}).eq("id",e);if(s)throw s}catch(h){throw h}}subscribeToLeadershipRequests(e,s){if(!e||"standalone"===e)return null;const t=n.channel(`leadership_requests_${e}`).on("postgres_changes",{event:"INSERT",schema:"public",table:"leadership_requests",filter:`session_id=eq.${e}`},e=>{setTimeout(()=>s(e),0)}).subscribe();return this.activeSubscriptions.set(`leadership_requests_${e}`,t),t}async getSessionFollowers(e){try{const{data:s,error:t}=await n.from("session_participants").select("\n          *,\n          users (\n            id,\n            name,\n            email,\n            role\n          )\n        ").eq("session_id",e).eq("is_active",!0);if(t)throw t;return s?.map(e=>e.users).filter(Boolean)||[]}catch(h){return[]}}async updateSession(e,s){this.updateLastActivity();const{data:t,error:r}=await n.from("performance_sessions").update(s).eq("id",e).select("\n        *,\n        setlists (name),\n        users (id, name, email, role),\n        sets (name),\n        songs (title, original_artist)\n      ").single();if(r)throw new Error(r.message);return t}async endSession(e){try{this.setActive(!1),this.cleanupSubscriptions(),await n.from("session_participants").update({is_active:!1}).eq("session_id",e);const{error:s}=await n.from("performance_sessions").update({is_active:!1}).eq("id",e);if(s)throw new Error(s.message);this.clearCache()}catch(h){throw h}}async leaveSession(e,s){try{await n.from("session_participants").update({is_active:!1}).eq("session_id",e).eq("user_id",s),this.setActive(!1),this.cleanupSubscriptions()}catch(h){throw h}}subscribeToSession(e,s){if(!e||"standalone"===e)return null;this.unsubscribeFromSession(e);const t=n.channel(`performance_session_${e}`).on("postgres_changes",{event:"UPDATE",schema:"public",table:"performance_sessions",filter:`id=eq.${e}`},e=>{setTimeout(()=>s(e),0)}).subscribe();return this.activeSubscriptions.set(`session_${e}`,t),t}subscribeToParticipants(e,s){if(!e||"standalone"===e)return null;const t=n.channel(`session_participants_${e}`).on("postgres_changes",{event:"*",schema:"public",table:"session_participants",filter:`session_id=eq.${e}`},e=>{setTimeout(()=>s(e),0)}).subscribe();return this.activeSubscriptions.set(`participants_${e}`,t),t}unsubscribeFromSession(e){const s=this.activeSubscriptions.get(`session_${e}`);s&&(n.removeChannel(s),this.activeSubscriptions.delete(`session_${e}`));const t=this.activeSubscriptions.get(`participants_${e}`);t&&(n.removeChannel(t),this.activeSubscriptions.delete(`participants_${e}`))}cleanupSubscriptions(){const e=this.getCachedSessionInfo();e.sessionId&&"standalone"!==e.sessionId&&n.auth.getUser().then(({data:{user:s}})=>{s&&n.from("session_participants").update({is_active:!1}).eq("session_id",e.sessionId).eq("user_id",s.id).then(()=>{}).catch(e=>{})});for(const[s,t]of this.activeSubscriptions)try{n.removeChannel(t)}catch(h){}this.activeSubscriptions.clear(),this.setActive(!1)}getCachedSessionInfo(){try{return{sessionId:localStorage.getItem(o.SESSION_ID),isLeader:"true"===localStorage.getItem(o.IS_LEADER)}}catch(h){return{sessionId:null,isLeader:!1}}}},d=Object.freeze(Object.defineProperty({__proto__:null,performanceService:c},Symbol.toStringTag,{value:"Module"}));class l extends Error{constructor(e,s="system"){super(e),this.name="ApiError",this.type=s}}const g=new class{constructor(){this.defaultTimeout=1e4,this.maxRetries=3,this.retryDelay=1e3}async withRetry(e,s=this.maxRetries){let t;for(let r=1;r<=s;r++)try{return await e()}catch(h){if(t=h,h.message?.includes("401")||h.message?.includes("403")||h.message?.includes("invalid")||"AbortError"===h.name)throw h;if(r<s){await this.delay(this.retryDelay*2**(r-1));continue}}throw t}async withTimeout(e,s=this.defaultTimeout){const t=new AbortController,r=setTimeout(()=>t.abort(),s);try{const s=await e(t.signal);return clearTimeout(r),s}catch(h){if(clearTimeout(r),"AbortError"===h.name)throw new l("Request timed out. Please check your connection and try again.","network");throw h}}async executeQuery(e,s={}){const{timeout:t=this.defaultTimeout,retries:r=this.maxRetries}=s;return this.withRetry(async()=>this.withTimeout(async s=>{const t=e();s&&t.abortSignal(s);const{data:r,error:i}=await t;if(i)throw new l(i.message,"system");return r},t),r)}async fetchWithRetry(e,s={},t={}){const{timeout:r=this.defaultTimeout,retries:i=this.maxRetries}=t;return this.withRetry(async()=>this.withTimeout(async t=>{const r=await fetch(e,{...s,signal:t});if(!r.ok){const e=await r.text();throw new l(e||`Request failed with ${r.status}`,"network")}return(r.headers.get("content-type")||"").includes("application/json")?r.json():r.text()},r),i)}delay(e){return new Promise(s=>setTimeout(s,e))}isRetryableError(e){const s=e.message?.toLowerCase()||"";return["network","timeout","connection","temporary","unavailable"].some(e=>s.includes(e))}formatError(e){return"string"==typeof e?e:"PGRST116"===e.code?"Record not found":e.code?.startsWith("23")?"A database constraint was violated. Please check your input.":"AbortError"===e.name||"network"===e.type?"Request timed out. Please try again.":e.message||"An unexpected error occurred. Please try again."}},w={getAllSongs:async()=>g.executeQuery(()=>n.from("songs").select("*").order("original_artist",{ascending:!0}).order("title",{ascending:!0})),async getSongById(e){if(!e)throw new Error("Song ID is required.");return g.executeQuery(()=>n.from("songs").select("*").eq("id",e).maybeSingle()).catch(e=>{if(e.message?.includes("PGRST116")||e.message?.includes("0 rows"))throw new Error("Song not found");throw e}).then(e=>{if(!e)throw new Error("Song not found");return e})},async createSong(e){const{original_artist:s,title:t,key_signature:r,lyrics:i,performance_note:o,tempo:a}=e,c=null!=a&&""!==a?Number(a):null;if(null!==c&&Number.isNaN(c))throw new Error("Tempo must be a valid number.");if(!s||!t)throw new Error("Artist and Title are required.");const{data:d,error:l}=await n.from("songs").select("id").eq("original_artist",s).eq("title",t).single();if(d)throw new Error("A song with this title and artist already exists.");if(l&&"PGRST116"!==l.code)throw new Error(l.message);const{data:g,error:w}=await n.from("songs").insert([{original_artist:s,title:t,key_signature:r,lyrics:i,performance_note:o,tempo:c}]).select().single();if(w)throw new Error(w.message);return g},async updateSong(e,s){const{original_artist:t,title:r,key_signature:i,lyrics:o,performance_note:a,tempo:c}=s,d=null!=c&&""!==c?Number(c):null;if(null!==d&&Number.isNaN(d))throw new Error("Tempo must be a valid number.");if(!t||!r)throw new Error("Artist and Title are required.");if(!e)throw new Error("Song ID is required.");const{data:l,error:g}=await n.from("songs").select("id").eq("id",e).maybeSingle();if(g)throw new Error(g.message);if(!l)throw new Error("Song not found.");const{data:w,error:_}=await n.from("songs").select("id").eq("original_artist",t).eq("title",r).neq("id",e);if(_)throw new Error(_.message);if(w&&w.length>0)throw new Error("Another song with this title and artist already exists.");const{data:m,error:u}=await n.from("songs").update({original_artist:t,title:r,key_signature:i,lyrics:o,performance_note:a,tempo:d}).eq("id",e).select().maybeSingle();if(u)throw new Error(u.message);if(!m)throw new Error("Failed to update song - song may have been deleted.");return m},async deleteSong(e){if(!e)throw new Error("Song ID is required.");const{data:s,error:t}=await n.from("songs").select("id").eq("id",e).maybeSingle();if(t)throw new Error(t.message);if(!s)throw new Error("Song not found.");const{error:r}=await n.from("songs").delete().eq("id",e);if(r)throw new Error(r.message)}},_={getAllSetlists:async()=>g.executeQuery(()=>n.from("setlists").select("*").order("name",{ascending:!0})),async getSetlistById(e){if(!e)throw new Error("Setlist ID is required.");const{data:s,error:t}=await n.from("setlists").select("\n        *,\n        sets (\n          id,\n          name,\n          set_order,\n          created_at\n        )\n      ").eq("id",e).order("set_order",{foreignTable:"sets",ascending:!0}).maybeSingle();if(t)throw new Error(t.message);if(!s)throw new Error("Setlist not found");return s},async createSetlist(e){const{name:s,user_id:t,is_public:r=!1}=e;if(!s||!t)throw new Error("Setlist name and user_id are required.");const{data:i,error:o}=await n.from("setlists").select("id").eq("name",s).eq("user_id",t).maybeSingle();if(o&&"PGRST116"!==o.code)throw new Error(o.message);if(i)throw new Error("A setlist with this name already exists.");const{data:a,error:c}=await n.from("setlists").insert([{name:s,user_id:t,is_public:r}]).select().single();if(c)throw new Error(c.message);return a},async updateSetlist(e,s){const{name:t,is_public:r}=s;if(!t)throw new Error("Setlist name is required.");if(!e)throw new Error("Setlist ID is required.");const{data:i,error:o}=await n.from("setlists").select("user_id").eq("id",e).maybeSingle();if(o)throw new Error(o.message);if(!i)throw new Error("Setlist not found");const{data:a,error:c}=await n.from("setlists").select("id").eq("name",t).eq("user_id",i.user_id).neq("id",e).maybeSingle();if(c&&"PGRST116"!==c.code)throw new Error(c.message);if(a)throw new Error("Another setlist with this name already exists.");const{data:d,error:l}=await n.from("setlists").update({name:t,is_public:r}).eq("id",e).select().maybeSingle();if(l)throw new Error(l.message);if(!d)throw new Error("Failed to update setlist - setlist may have been deleted.");return d},async deleteSetlist(e){if(!e)throw new Error("Setlist ID is required.");const{data:s,error:t}=await n.from("setlists").select("id").eq("id",e).maybeSingle();if(t)throw new Error(t.message);if(!s)throw new Error("Setlist not found.");const{error:r}=await n.from("setlists").delete().eq("id",e);if(r)throw new Error(r.message)},async duplicateSetlist(e,s,t,r=!1){if(!e||!s||!t)throw new Error("Source setlist ID, new setlist name and user_id are required.");const{data:i,error:o}=await n.from("setlists").select("id").eq("name",s).eq("user_id",t).maybeSingle();if(o&&"PGRST116"!==o.code)throw new Error(o.message);if(i)throw new Error("A setlist with this name already exists.");const a=await this.getSetlistById(e),{data:c,error:d}=await n.from("setlists").insert([{name:s,user_id:t,is_public:r}]).select().single();if(d)throw new Error(d.message);for(const l of a.sets||[]){const{data:e,error:s}=await n.from("sets").select("\n          *,\n          set_songs (\n            song_order,\n            songs (id)\n          )\n        ").eq("id",l.id).maybeSingle();if(s||!e)continue;const{data:t,error:r}=await n.from("sets").insert([{name:e.name,setlist_id:c.id,set_order:e.set_order}]).select().single();if(!r&&t&&(e.set_songs&&e.set_songs.length>0)){const s=e.set_songs.map(e=>({set_id:t.id,song_id:e.songs.id,song_order:e.song_order})),{error:r}=await n.from("set_songs").insert(s)}}return c}},m={getAllSongCollections:async()=>g.executeQuery(()=>n.from("song_collections").select("*").order("name",{ascending:!0})),async getSongCollectionById(e){if(!e)throw new Error("Song collection ID is required.");const{data:s,error:t}=await n.from("song_collections").select("\n        *,\n        song_collection_songs (\n          song_order,\n          songs (\n            id,\n            original_artist,\n            title,\n            key_signature,\n            tempo,\n            performance_note\n          )\n        )\n      ").eq("id",e).order("song_order",{foreignTable:"song_collection_songs",ascending:!0}).maybeSingle();if(t)throw new Error(t.message);if(!s)throw new Error("Song collection not found");return s},async createSongCollection(e){const{name:s,songs:t,user_id:r,is_public:i=!1}=e;if(!s||!r)throw new Error("Collection name and user_id are required.");const{data:o,error:a}=await n.from("song_collections").select("id").eq("name",s).eq("user_id",r).single();if(o)throw new Error("A song collection with this name already exists.");if(a&&"PGRST116"!==a.code)throw new Error(a.message);const{data:c,error:d}=await n.from("song_collections").insert([{name:s,user_id:r,is_public:i}]).select().single();if(d)throw new Error(d.message);if(t&&t.length>0){const e=t.map(e=>({song_collection_id:c.id,song_id:e.song_id,song_order:e.song_order})),{error:s}=await n.from("song_collection_songs").insert(e);if(s)throw await n.from("song_collections").delete().eq("id",c.id),new Error(s.message)}return c},async updateSongCollection(e,s){const{name:t,songs:r,is_public:i}=s;if(!t)throw new Error("Collection name is required.");if(!e)throw new Error("Collection ID is required.");const{data:o,error:a}=await n.from("song_collections").select("user_id").eq("id",e).maybeSingle();if(a)throw new Error(a.message);if(!o)throw new Error("Song collection not found");const{data:c,error:d}=await n.from("song_collections").select("id").eq("name",t).eq("user_id",o.user_id).neq("id",e);if(d)throw new Error(d.message);if(c&&c.length>0)throw new Error("Another song collection with this name already exists.");const{data:l,error:g}=await n.from("song_collections").update({name:t,is_public:i}).eq("id",e).select().single();if(g)throw new Error(g.message);if(void 0!==r){const{error:s}=await n.from("song_collection_songs").delete().eq("song_collection_id",e);if(s)throw new Error(s.message);if(r.length>0){const s=r.map(s=>({song_collection_id:e,song_id:s.song_id,song_order:s.song_order})),{error:t}=await n.from("song_collection_songs").insert(s);if(t)throw new Error(t.message)}}return l},async deleteSongCollection(e){const{error:s}=await n.from("song_collections").delete().eq("id",e);if(s)throw new Error(s.message)}},u={async getSetsBySetlistId(e){const{data:s,error:t}=await n.from("sets").select("*").eq("setlist_id",e).order("set_order",{ascending:!0});if(t)throw new Error(t.message);return s},async getSetById(e){if(!e)throw new Error("Set ID is required.");const{data:s,error:t}=await n.from("sets").select("\n        *,\n        setlists (name),\n        set_songs (\n          song_order,\n          songs (\n            id,\n            original_artist,\n            title,\n            key_signature,\n            tempo,\n            performance_note,\n            lyrics\n          )\n        )\n      ").eq("id",e).order("song_order",{foreignTable:"set_songs",ascending:!0}).maybeSingle();if(t)throw new Error(t.message);if(!s)throw new Error("Set not found");return s},async createSet(e){const{name:s,setlist_id:t,songs:r}=e;if(!s||!t)throw new Error("Set name and setlist_id are required.");const{data:i,error:o}=await n.from("setlists").select("id").eq("id",t).maybeSingle();if(o)throw new Error(o.message);if(!i)throw new Error("Setlist not found.");if(r&&r.length>0){const e=await this.checkForDuplicatesInSetlist(t,r.map(e=>e.song_id),null,!0);if(e.length>0)throw new Error(JSON.stringify({type:"DUPLICATES_FOUND",duplicates:e,message:"Some songs already exist in other sets within this setlist"}))}const{data:a,error:c}=await n.from("sets").select("set_order").eq("setlist_id",t).order("set_order",{ascending:!1}).limit(1);if(c)throw new Error(c.message);const d=a&&a.length>0?a[0].set_order+1:1,{data:l,error:g}=await n.from("sets").insert([{name:s,setlist_id:t,set_order:d}]).select().maybeSingle();if(g)throw new Error(g.message);if(r&&r.length>0){const e=r.map(e=>({set_id:l.id,song_id:e.song_id,song_order:e.song_order})),{error:s}=await n.from("set_songs").insert(e);if(s)throw await n.from("sets").delete().eq("id",l.id),new Error(s.message)}return l},async updateSet(e,s){const{name:t,songs:r}=s;if(!t)throw new Error("Set name is required.");if(!e)throw new Error("Set ID is required.");const{data:i,error:o}=await n.from("sets").select("id, setlist_id").eq("id",e).maybeSingle();if(o)throw new Error(o.message);if(!i)throw new Error("Set not found.");if(void 0!==r&&r.length>0){const s=await this.checkForDuplicatesInSetlist(i.setlist_id,r.map(e=>e.song_id),e,!0);if(s.length>0)throw new Error(JSON.stringify({type:"DUPLICATES_FOUND",duplicates:s,message:"Some songs already exist in other sets within this setlist"}))}const{data:a,error:c}=await n.from("sets").update({name:t}).eq("id",e).select().maybeSingle();if(c)throw new Error(c.message);if(!a)throw new Error("Failed to update set - set may have been deleted.");if(void 0!==r){const{error:s}=await n.from("set_songs").delete().eq("set_id",e);if(s)throw new Error(s.message);if(r.length>0){const s=r.map(s=>({set_id:e,song_id:s.song_id,song_order:s.song_order})),{error:t}=await n.from("set_songs").insert(s);if(t)throw new Error(t.message)}}return a},async deleteSet(e){if(!e)throw new Error("Set ID is required.");const{data:s,error:t}=await n.from("sets").select("id").eq("id",e).maybeSingle();if(t)throw new Error(t.message);if(!s)throw new Error("Set not found.");const{error:r}=await n.from("sets").delete().eq("id",e);if(r)throw new Error(r.message)},async checkForDuplicatesInSetlist(e,s,t=null,r=!1){let i=n.from("set_songs").select(r?"\n        song_id,\n        sets!inner(id, name, setlist_id),\n        songs(title, original_artist)\n      ":"\n        song_id,\n        sets!inner(id, setlist_id)\n      ").eq("sets.setlist_id",e).in("song_id",s);t&&(i=i.neq("sets.id",t));const{data:o,error:a}=await i;if(a)throw new Error(a.message);return o||[]},async checkCollectionDuplicates(e,s,t=null){return(await this.checkForDuplicatesInSetlist(e,s,null,!0)).reduce((e,s)=>{const r=s.sets.id;return e[r]||(e[r]={setName:s.sets.name,isCurrentSet:r===t,songs:[]}),e[r].songs.push({id:s.song_id,title:s.songs.title,original_artist:s.songs.original_artist}),e},{})},async moveSongsBetweenSets(e,s,t){const{error:r}=await n.from("set_songs").delete().in("song_id",e);if(r)throw new Error(r.message);const{data:i}=await n.from("set_songs").select("song_order").eq("set_id",t).order("song_order",{ascending:!1}).limit(1);let o=(i&&i[0]?.song_order||0)+1;const a=e.map(e=>({set_id:t,song_id:e,song_order:o++})),{error:c}=await n.from("set_songs").insert(a);if(c)throw new Error(c.message)},async moveSongToSet(e,s,t,r=null){const{data:i,error:o}=await n.from("sets").select("setlist_id").in("id",[s,t]);if(o)throw new Error(o.message);if(2!==i.length||i[0].setlist_id!==i[1].setlist_id)throw new Error("Both sets must be in the same setlist");const{error:a}=await n.from("set_songs").delete().eq("set_id",s).eq("song_id",e);if(a)throw new Error(a.message);if(!r){const{data:e}=await n.from("set_songs").select("song_order").eq("set_id",t).order("song_order",{ascending:!1}).limit(1);r=(e&&e[0]?.song_order||0)+1}const{error:c}=await n.from("set_songs").insert({set_id:t,song_id:e,song_order:r});if(c)throw new Error(c.message)},async reorderSongs(e,s){const t=Object.entries(s).map(([s,t])=>({set_id:e,song_id:s,song_order:t})),{error:r}=await n.from("set_songs").delete().eq("set_id",e);if(r)throw new Error(r.message);const{error:i}=await n.from("set_songs").insert(t);if(i)throw new Error(i.message)},async removeSongFromSet(e,s){const{error:t}=await n.from("set_songs").delete().eq("set_id",e).eq("song_id",s);if(t)throw new Error(t.message)}};export{_ as a,w as b,m as c,u as d,g as e,d as f,t as g,c as p,n as s};
